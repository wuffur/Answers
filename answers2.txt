1.Что такое factory, каким образом используется и для чего?
Класс Factory - это объект ядра, и это объект который используется для создания других объектов ядра. 
Из-за этого он называется фабрикой(Factory). Вы можете использовать его как возможность,например, для нитей, 
чтобы создать объект. Причина по которой он создается это ограничение способностей нитей создать определенный
объект. И используя его никогда не будет установлено сообщение между определенными объектами.
L4re::Factory* factory()= L4Re::Env::env()->factory();
L4Re::Env::env() - дает программе доступ к изначальному окружению(среде) возможностей.
2.Что такое target_cap, thread_cap? Область видимости gate.
l4_msgtag_t tag = factory->create_gate(target_cap, thread_cap, label);
Target capability и thread capability соответственно.
Создает объект IPC gate.
Может быть создано несколько объектов gate. Чтобы определить через какой gate прошло ставится label.

Если вы хотите создать новый объект, то вам нужно создать новую способность для этого объекта. Способность это ничего 
более, чем способность создать задание в capability table. И пользователь создает новый объект, чтобы определить с каким 
объект должен быть связан его вызов.
Таким образом - target_cap - это свободный слот в таблице способностей задач. Слот указывает на новый созданный объект.
Обычно размещаясь с помощью L4Re::Util::cap_alloc.alloc().
Теперь нити позволено посылать/принимать сообщения через этот gate.
thread_cap - нить связана с CPU, поэтому у нити тоже есть определенные возможности, она может быть заблокирована и так далее.

3.Структура utcb и назначение каждого из полей.
User-level thread control block(блок управления нитями пользовательского уровня) содержит:
-message registered(хранят параметры системных вызовов, все данные напрямую копируются получателю(в ядро))
-buffer registered(используется для хранения flexpage descripters(дискриптеры гибких страниц), они содержат разновидность
дескрипторов ресурсов, они позволяют вам пердать вызов ресурса кому-то другому(может быть плохо расслышал 
и там упаковать ресурс, для передачи его кому-то другому)).
-thread registeres(поскольку threads относятся к CPU, то они хранят специфическую для CPU информацию.
thread-private data(закрытые, внутренние для нити данные, 
preserved, not copied и данные там сохраняются от одной нити, а не копируются из других)

4.Что происходит, когда истекает timeout в ipc?
Если обращение происходит по несуществующему адресу, то разблокирует до timeout, если по существующему, то ядро блокирует тебя до timeout, 
после этого оно тебя разблокирует.

5.Есть ли ограничения на длинну ipc message?
Можно установить переменную size, которая будет указывать количество char символов(размер char*),
Все они записываются последовательн, вначале пишутся 8 байт(2 integers) OP1_opcode и первый аргумент, для каждого процесса и происходит округление до границы следющего целого числа,
поскольку обращение идентификатора происходит по int, сверху размер буффера для всех текущих IPC messages ограничен константой 
4*INT_MAX(IEEE INT_MAX = 2147483647), а одно сообщение не может быть больше UINT_MAX-2( размер которого IEEE UINT_MAX=4294967295). 
6.Что такое IDL compiler, зачем он нужен и какие проблемы решает?
IDL - язык определения интерфейса.
Интерфейс для функций предлагаемых сервисом, предлагается для автоматизации получения сообщений.
IDL компилятор автоматически генерирует IPC код.
Работает для старых версий L4 environment:
DICE - Drops Idl CompilEr Сейчас не обслуживается(наверное он для C).
 - Используются потоковые операторы, чтобы сделать IPC более современным
 компилятор заботится о сериализации основных типов данных в правильном месте.
 - потоковые библиотеки могут абстрагироваться от лежащего в основе ядра
  заново использовать тот же код на разных ядрах
  интенсивно используется в genode
 - пользователи работают со специальными IPC потоковыми объектами
 - хорошие новости - это может быть комбинировано с IDL compiler

7.Как эти проблемы решены в gnu/mach (вдруг вы знаете), как они решаются в l4re?


8.Communication channel и ipc gate - одно и то же?
9.Так все же, каким образом сервер узнают какую dispatch функцию вызывать?
10.А если у нас несколько каналов?
11.Опишите пожалуйста механизм работы sigma0, каким образом обрабатываются page fault?
12.У каждого треда есть pager - обработчик page fault.
13.Что такое flexpage и зачем это нужно?
14.Опишите пожалуйста проблему иерархических мапингов и метод ее решения в fiasco.oc
15.Что такое dataspace, каким образом с этой абстракцией осцществляетс работа?
16.Как используюя dataspace передавать данные между серверами
