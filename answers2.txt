1.Что такое factory, каким образом используется и для чего?
Класс Factory - это объект ядра, и это объект который используется для создания других объектов ядра. 
Из-за этого он называется фабрикой(Factory). Вы можете использовать его как возможность,например, для нитей, 
чтобы создать объект. Причина по которой он создается это ограничение способностей нитей создать определенный
объект. И используя его никогда не будет установлено сообщение между определенными объектами.
L4re::Factory* factory()= L4Re::Env::env()->factory();
L4Re::Env::env() - дает программе доступ к изначальному окружению(среде) возможностей.
2.Что такое target_cap, thread_cap? Область видимости gate.
l4_msgtag_t tag = factory->create_gate(target_cap, thread_cap, label);
Target capability и thread capability соответственно.
Создает объект IPC gate.
Может быть создано несколько объектов gate. Чтобы определить через какой gate прошло ставится label.

Если вы хотите создать новый объект, то вам нужно создать новую способность для этого объекта. Способность это ничего 
более, чем способность создать задание в capability table. И пользователь создает новый объект, чтобы определить с каким 
объект должен быть связан его вызов.
Таким образом - target_cap - это свободный слот в таблице способностей задач. Слот указывает на новый созданный объект.
Обычно размещаясь с помощью L4Re::Util::cap_alloc.alloc().
Теперь нити позволено посылать/принимать сообщения через этот gate.
thread_cap - нить связана с CPU, поэтому у нити тоже есть определенные возможности, она может быть заблокирована и так далее.

3.Структура utcb и назначение каждого из полей.
User-level thread control block(блок управления нитями пользовательского уровня) содержит:
-message registered(хранят параметры системных вызовов, все данные напрямую копируются получателю(в ядро))
-buffer registered(используется для хранения flexpage descripters(дискриптеры гибких страниц), они содержат разновидность
дескрипторов ресурсов, они позволяют вам пердать вызов ресурса кому-то другому(может быть плохо расслышал 
и там упаковать ресурс, для передачи его кому-то другому)).
-thread registeres(поскольку threads относятся к CPU, то они хранят специфическую для CPU информацию.
thread-private data(закрытые, внутренние для нити данные, 
preserved, not copied и данные там сохраняются от одной нити, а не копируются из других)

4.Что происходит, когда истекает timeout в ipc?
Если обращение происходит по несуществующему адресу, то разблокирует до timeout, если по существующему, то ядро блокирует тебя до timeout, 
после этого оно тебя разблокирует.

5.Есть ли ограничения на длинну ipc message?
Можно установить переменную size, которая будет указывать количество char символов(размер char*),
Все они записываются последовательн, вначале пишутся 8 байт(2 integers) OP1_opcode и первый аргумент, для каждого процесса и происходит округление до границы следющего целого числа,
поскольку обращение идентификатора происходит по int, сверху размер буффера для всех текущих IPC messages ограничен константой 
4*INT_MAX(IEEE INT_MAX = 2147483647), а одно сообщение не может быть больше UINT_MAX-2( размер которого IEEE UINT_MAX=4294967295). 
6.Что такое IDL compiler, зачем он нужен и какие проблемы решает?
IDL - язык определения интерфейса.
Интерфейс для функций предлагаемых сервисом, предлагается для автоматизации получения сообщений.
IDL компилятор автоматически генерирует IPC код.
Работает для старых версий L4 environment:
DICE - Drops Idl CompilEr Сейчас не обслуживается(наверное он для C).
 - Используются потоковые операторы, чтобы сделать IPC более современным
 компилятор заботится о сериализации основных типов данных в правильном месте.
 - потоковые библиотеки могут абстрагироваться от лежащего в основе ядра
  заново использовать тот же код на разных ядрах
  интенсивно используется в genode
 - пользователи работают со специальными IPC потоковыми объектами
 - хорошие новости - это может быть комбинировано с IDL compiler

7.Как эти проблемы решены в gnu/mach (вдруг вы знаете), как они решаются в l4re?


8.Communication channel и ipc gate - одно и то же?
9.Так все же, каким образом сервер узнают какую dispatch функцию вызывать?
сервер ждёт сообщение recv_message() от него передается параметр
который он передает dispatch функции для отправки, то есть ему нужно подождать это сообщение прочитать, и 
ответить reply на него клиенту, причем чтобы ответить нужно и само сообщение(наверное те 2 байта - op1_code и 
первый аргумент) и то что передала dispatch функция.
также пользователю нужно передавать look_hooks() параметры для того чтобы получить IPC error, wait timeout и 
подготовки к ожиданию.
У сервера должна быть специальная функция предназначенная для отправки

10.А если у нас несколько каналов?

11.Опишите пожалуйста механизм работы sigma0, каким образом обрабатываются page fault?
l4sigma0_return_flags_t - возвращает флаги:

L4SIGMA0_OK  
Ок.

L4SIGMA0_NOTALIGNED 	
Физическая, виртуальная  или размер не выравнен.

L4SIGMA0_IPCERROR 	
IPC ошибка.

L4SIGMA0_NOFPAGE 	
Не получена fpage.

L4SIGMA0_SMALLERFPAGE 	
Запрашивается superpage, но получена меньшая flexpage.

Либо unknown_error

int l4sigma0_map_kip - размещает информационную страницу ядра от pager по адресу addr
int l4sigma0_map_mem - запрашивает размещение памяти из  sigma0
int  l4sigma0_map_iomem - 	запрашивает память IO для sigma0. 
int l4sigma0_map_anypage - размещение на любой странице
void l4sigma0_debug_dump - размещает отладочную информацию
int l4sigma0_new_client - создает нового IPC gate для нового sigma0 клиента
char const * l4sigma0_map_errstr - возвращает читаемое сообщение об ошибке для кодов возврата

page fault передаётся page fault handler'у в ядре. 
12.У каждого треда есть pager - обработчик page fault.
У каждой нити есть обработчик fault handler на user level'е связанный с ним, называется the pager.
У него есть свой исполняемый код и своя память.
13.Что такое flexpage и зачем это нужно?
Flexpage - это специальная структура данных
она содержит адрес страницы(20 байт), размер страницы(6 байт) ~ - похоже на выравнивание(2байта) и права(4байт).
контроль за ними проводит UTCB, она хранит в буфферных регистрах место их расположения.
14.Опишите пожалуйста проблему иерархических мапингов и метод ее решения в fiasco.oc
Fiasco.OC изначально размещает всю память в sigma0, поэтому он никогда не говорит о проблемах с памятью.
Произвольно размещая память, поэтому если вы хотите разместить в подходящем куске памяти, в котором недавно разместилось
уже что-то, то его просто разместят в другое свободное user space и вам не нужно будет об этом заботиться, поскольку ядро
позаботиться. Если вам нужно сложное размещение в памяти, то можно не пользоваться стеком памяти(stack pager). И pager'ы
могут образовывать stack pager hierarchy.
Pager`ы могут использовать другие pager'ы для размещения, а сами приложения могут использовать один pager верхнего уровня,
что будет объеденино на pager'е нижнего уровня - это может быть удобно для доступа к драйверам устройств. А в физической
памяти будут находиться так или иначе размещенные области памяти из всех планировщиков, объединенные в удобный стек.
Все pager'ы между тем друг от друга программно изолированы.
Для разрешения проблем, на каком уровне и с каким планировщиком произошла  ошибка существует region mapper. Он содержит
начало и конец каждого pager'а в виртуальной памяти.
И во-первых это первая нить внутри задания L4Re, а во-вторых он содержит адреса размешения области памяти pager'а.

15.Что такое dataspace, каким образом с этой абстракцией осцществляетс работа?
Dataspace - это  обобщенная абстракция для отображения памяти. Пространства адресов могут состоять из различных источников:
 Бинарники - секция кода/данных.
 файловая система - размещенные в памяти файлы
 анонимная память - стеки
 сетевые пакеты 
 пространства MMIO устройств(мультимедия устройства ввода/вывода)
 Регионы отображения не заботятся о деталях. Они только управляют регионом содержащим страницы
 основные объекты памяти - dataspace
 детальная реализация содержится в менеджере управления памятью.
 У объекта есть способность создавать dataspace.
 Приложение спрашивает свой RM(объект отображения в памяти),чтобы прикрепить этот dataspace к памяти.
 Приложение теперь будет использовать это dataspaceб чтобы просто обращаться к памяти.
 
16.Как используюя dataspace передавать данные между серверами
Если на одной физической машине, то можно использовать механизмы ядра для сообщения между серверами, если на разных, то 
приложению-серверу нужно создавать клиент(в любом случае один будет send, а другой recv), который будет передавать сообщения серверу и посредствам этого взаимодействовать. Второй вариант
может быть реализован и в первом случае. Клиент может передавать dataspace серверу.
